name: "Command substitution"
cases:
  - name: "Command substitution"
    stdin: |
      var="value"

      echo "1:"
      echo $(echo hi)
      echo "2:"
      echo "$(echo hi)"
      echo "3:"
      echo "$(echo "hi")"
      echo "4:"
      echo "$(var="updated"; echo ${var})"
      echo "var=${var}"

  - name: "Command substitution with embedded parens"
    stdin: |
      x=$(echo foo | (wc -l; echo hi))
      echo "\$x: $x"

  - name: "Command substitution with subshell"
    stdin: |
      x=$( (echo hi) )
      echo "\$x: $x"

  - name: "Command substitution exit code"
    stdin: |
      x=$(false) && echo "1. Made it past false"
      y=$(true) && echo "2. Made it past true"

  - name: "Command substitution with exec"
    stdin: |
      x=$(exec echo hi)
      echo "x: $x"

  - name: "Backtick command substitution"
    stdin: |
      echo `echo hi`

  - name: "Backtick command substitution with escaping"
    stdin: |
      echo `echo \`echo hi\``

  - name: "Backtick command substitution with backslashes"
    stdin: |
      echo `echo \\`

  - name: "Backtick command substitution in double quotes"
    stdin: |
      echo "`echo First line`"
      echo " `echo Second line` "
      echo "Third`echo line`here"

  - name: "Ignore single quote in comment in command substitution"
    stdin: |
      var=$(
        # I'm
        echo "Batman"
      )
      echo $var

  - name: "Ignore double quote in comment in command substitution"
    stdin: |
      var=$(
        # This " is not being
        echo "parsed"
      )
      echo $var

  - name: "Ignore parentheses in comment in command substitution"
    stdin: |
      var=$(
        # :(
        echo "Sad"
      )
      echo $var

  - name: "Ignore dollar in comment in command substitution"
    stdin: |
      var=$(
        #               $
        echo "Mr. Crabs ^"
      )
      echo $var

  - name: "Positional parameter count not mistaken for comment"
    stdin: |
      echo $(echo $#)

  - name: "Ignore single quote in comment in command substitution (backticks)"
    stdin: |
      var=`
        # I'm
        echo "Batman"
      `
      echo $var

  - name: "Ignore double quote in comment in command substitution (backticks)"
    stdin: |
      var=`
        # This " is not being
        echo "parsed"
      `
      echo $var

  - name: "Ignore parentheses in comment in command substitution (backticks)"
    stdin: |
      var=`
        # :(
        echo "Sad"
      `
      echo $var

  - name: "Ignore dollar in comment in command substitution (backticks)"
    stdin: |
      var=`
        #               $
        echo "Mr. Crabs ^"
      `
      echo $var

  - name: "Positional parameter count not mistaken for comment (backticks)"
    stdin: |
      echo `echo $#`

  - name: "Command substitution with only input redir"
    stdin: |
      echo "Some text" >file.txt
      x=$(<file.txt)
      echo "x: $x"

  - name: "Command substitution with only input redir in pipeline"
    known_failure: true
    ignore_stderr: true
    test_files:
      - path: file.txt
        contents: |
          File Contents
    stdin: |
      x=$(<non-existent-file.txt) || x=$(<file.txt)
      echo "\$?: $?"
      echo "x: $x"

  - name: "Backquote with only input redir"
    stdin: |
      echo "Some text" >file.txt
      x=`<file.txt`
      echo "x: $x"

  - name: "Command substitution as simple command preserves exit code"
    stdin: |
      $(false)
      echo "exit code: $?"

      $(true)
      echo "exit code: $?"

      $(exit 42)
      echo "exit code: $?"

  - name: "Backtick substitution as simple command preserves exit code"
    stdin: |
      `false`
      echo "exit code: $?"

      `true`
      echo "exit code: $?"

  - name: "Command substitution with exec as simple command"
    stdin: |
      $(exec true)
      echo "exit code: $?"

      $(exec false)
      echo "exit code: $?"

  - name: "Nested command substitution exit code"
    stdin: |
      $($(false))
      echo "exit code: $?"

      $($(:))
      echo "exit code: $?"

  - name: "Nested command substitution output"
    stdin: |
      echo "$(echo "$(echo hello)")"

  - name: "Deeply nested command substitution"
    stdin: |
      echo "$(echo "$(echo "$(echo deep)")")"

  - name: "Nested command substitution with variable"
    stdin: |
      x="inner"
      result="$(echo "prefix-$(echo "$x")-suffix")"
      echo "$result"

  - name: "Nested command substitution with pipe"
    stdin: |
      result=$(echo "hello world" | $(echo cat))
      echo "$result"

  - name: "Command substitution in arithmetic"
    stdin: |
      echo "$(( $(echo 10) + $(echo 20) ))"

  - name: "Nested command substitution with process substitution"
    stdin: |
      result=$(cat <(echo "from proc sub"))
      echo "$result"

  - name: "Triple nested command substitution"
    stdin: |
      echo "$(echo "a$(echo "b$(echo c)b")a")"

  - name: "Command substitution with loop"
    stdin: |
      result=$(for i in 1 2 3; do echo "$i"; done)
      echo "$result"

  - name: "Nested backtick and dollar-paren substitution"
    stdin: |
      echo "$(echo `echo mixed`)"

  - name: "Command substitution with conditional"
    stdin: |
      x=5
      result=$(if [[ $x -gt 3 ]]; then echo "big"; else echo "small"; fi)
      echo "$result"

  - name: "Command substitution capturing stderr via redirection"
    stdin: |
      result=$(echo "error msg" >&2 2>&1)
      echo "result: $result"

  - name: "Command substitution with quoted closing paren"
    stdin: |
      f() {
        echo $(echo ")")
      }
      f

name: "Options: set -e"
cases:
  # Basic behavior
  - name: "Basic non-error case"
    stdin: |
      set -e
      true
      echo "Text after call"

  - name: "Basic error case"
    stdin: |
      set -e
      false
      echo "Text after call"

  - name: "Multiple commands before error"
    stdin: |
      set -e
      echo "first"
      echo "second"
      false
      echo "should not print"

  - name: "Error in middle of script"
    stdin: |
      set -e
      echo "before"
      false
      echo "after"

  - name: "Error in if condition"
    stdin: |
      set -e
      if false; then
        echo "then branch"
      else
        echo "else branch"
      fi
      echo "after if"

  - name: "Error in if condition with compound test"
    stdin: |
      set -e
      if false && false; then
        echo "then"
      else
        echo "else"
      fi
      echo "after"

  - name: "Error in while condition"
    stdin: |
      set -e
      count=0
      while false; do
        echo "loop body"
      done
      echo "after while"

  - name: "Error in until condition"
    stdin: |
      set -e
      count=0
      until true; do
        echo "loop body"
      done
      echo "after until"

  - name: "Error in if body DOES exit"
    stdin: |
      set -e
      if true; then
        false
        echo "should not print"
      fi
      echo "after if"

  - name: "Error in else body DOES exit"
    stdin: |
      set -e
      if false; then
        echo "then"
      else
        false
        echo "should not print"
      fi
      echo "after if"

  - name: "Error in while body DOES exit"
    stdin: |
      set -e
      count=0
      while [ $count -lt 2 ]; do
        count=$((count + 1))
        false
        echo "should not print"
      done
      echo "after while"

  # Boolean operators - set -e should NOT exit with && and ||
  - name: "Error on right side of &&"
    stdin: |
      set -e
      true && false
      echo "after &&"

  - name: "Error on left side of &&"
    stdin: |
      set -e
      false && true
      echo "after &&"

  - name: "Error on right side of ||"
    stdin: |
      set -e
      false || false
      echo "after ||"

  - name: "Error on left side of ||"
    stdin: |
      set -e
      true || false
      echo "after ||"

  - name: "Error after && chain DOES exit"
    stdin: |
      set -e
      true && true
      false
      echo "should not print"

  - name: "Complex boolean expression"
    stdin: |
      set -e
      false || true && false || true
      echo "after complex expression"

  - name: "Negated command with failure"
    stdin: |
      set -e
      ! false
      echo "after negation"

  - name: "Negated command with success"
    stdin: |
      set -e
      ! true
      echo "after negation"

  - name: "Error after negated command"
    stdin: |
      set -e
      ! false
      false
      echo "should not print"

  # Pipelines
  - name: "Error in first command of pipeline (without pipefail)"
    stdin: |
      set -e
      false | true
      echo "after pipeline"

  - name: "Error in first command of pipeline (without pipefail, negated)"
    stdin: |
      set -e
      ! false | true
      echo "after pipeline"

  - name: "Error in first command of pipeline (with pipefail)"
    stdin: |
      set -e -o pipefail
      false | true
      echo "after pipeline"

  - name: "Error in first command of pipeline (with pipefail, negated)"
    stdin: |
      set -e -o pipefail
      ! false | true
      echo "after pipeline"

  - name: "Error in middle of pipeline (without pipefail)"
    stdin: |
      set -e
      true | false | true
      echo "after pipeline"

  - name: "Error in middle of pipeline (without pipefail, negated)"
    stdin: |
      set -e
      ! true | false | true
      echo "after pipeline"

  - name: "Error in middle of pipeline (with pipefail)"
    stdin: |
      set -e -o pipefail
      true | false | true
      echo "after pipeline"

  - name: "Error in middle of pipeline (with pipefail, negated)"
    stdin: |
      set -e -o pipefail
      ! true | false | true
      echo "after pipeline"

  - name: "Error in last command of pipeline (without pipefail)"
    stdin: |
      set -e
      true | false
      echo "after pipeline"

  - name: "Error in last command of pipeline (without pipefail, negated)"
    stdin: |
      set -e
      ! true | false
      echo "after pipeline"

  - name: "Error in last command of pipeline (with pipefail)"
    stdin: |
      set -e -o pipefail
      true | false
      echo "after pipeline"

  - name: "Error in last command of pipeline (with pipefail, negated)"
    stdin: |
      set -e -o pipefail
      ! true | false
      echo "after pipeline"

  - name: "Pipeline in conditional"
    stdin: |
      set -e
      if true | false; then
        echo "then"
      else
        echo "else"
      fi
      echo "after"

  - name: "Negated pipeline"
    stdin: |
      set -e
      ! false | false
      echo "after"

  # Functions
  - name: "Error in function body exits function and script"
    stdin: |
      set -e
      myfunc() {
        echo "in function"
        false
        echo "should not print in function"
      }
      myfunc
      echo "should not print after function"

  - name: "Function returning error in conditional"
    stdin: |
      set -e
      myfunc() {
        false
      }
      if myfunc; then
        echo "then"
      else
        echo "else"
      fi
      echo "after"

  - name: "Function called with &&"
    stdin: |
      set -e
      myfunc() {
        false
      }
      true && myfunc
      echo "after"

  - name: "Function called with ||"
    stdin: |
      set -e
      myfunc() {
        false
      }
      false || myfunc
      echo "after"

  - name: "Function called with negation"
    stdin: |
      set -e
      myfunc() {
        false
      }
      ! myfunc
      echo "after"

  - name: "Error in function body with set -e inside function"
    stdin: |
      myfunc() {
        set -e
        echo "before error"
        false
        echo "should not print"
      }
      myfunc
      echo "after function call"

  - name: "Function with explicit return still respects set -e"
    stdin: |
      set -e
      myfunc() {
        false
        return 0
      }
      myfunc
      echo "after function"

  # Subshells
  - name: "Error in subshell exits subshell but not parent"
    stdin: |
      set -e
      (
        echo "in subshell"
        false
        echo "should not print in subshell"
      )
      echo "after subshell"

  - name: "Subshell with set -e exits on error"
    stdin: |
      (
        set -e
        echo "before"
        false
        echo "should not print"
      )
      echo "after subshell"

  - name: "Subshell failure in conditional"
    stdin: |
      set -e
      if (false); then
        echo "then"
      else
        echo "else"
      fi
      echo "after"

  - name: "Subshell with &&"
    stdin: |
      set -e
      true && (false)
      echo "after"

  # Command substitution
  - name: "Error in command substitution"
    stdin: |
      set -e
      result=$(false)
      echo "after command substitution"

  - name: "Error in command substitution with assignment"
    stdin: |
      set -e
      var=$(false; echo "value")
      echo "var is: $var"
      echo "after"

  - name: "Command substitution in conditional"
    stdin: |
      set -e
      if [ "$(false; echo no)" = "no" ]; then
        echo "matched"
      fi
      echo "after"

  - name: "set +e disables error exit"
    stdin: |
      set -e
      echo "with -e"
      set +e
      false
      echo "after false with +e"

  - name: "set -e can be re-enabled"
    stdin: |
      set -e
      set +e
      false
      echo "after false with +e"
      set -e
      false
      echo "should not print"

  - name: "set +e in function"
    stdin: |
      set -e
      myfunc() {
        set +e
        false
        echo "in function after false"
      }
      myfunc
      false
      echo "should not print"

  # Exit status handling
  - name: "Non-zero exit status triggers exit"
    stdin: |
      set -e
      (exit 1)
      echo "should not print"

  - name: "Specific non-zero exit status"
    stdin: |
      set -e
      (exit 42)
      echo "should not print"

  - name: "Zero exit status"
    stdin: |
      set -e
      (exit 0)
      echo "after exit 0"

  # Assignment with command substitution
  - name: "Assignment from failing command"
    stdin: |
      set -e
      var=$(false) || true
      echo "after assignment"

  - name: "Local variable assignment with failing command"
    stdin: |
      set -e
      myfunc() {
        local var=$(false)
        echo "after local"
      }
      myfunc
      echo "after function"

  # Complex scenarios
  - name: "Error after successful conditional"
    stdin: |
      set -e
      if true; then
        echo "in if"
      fi
      false
      echo "should not print"

  - name: "Nested conditionals with error"
    stdin: |
      set -e
      if true; then
        if false; then
          echo "inner then"
        else
          echo "inner else"
        fi
        echo "after inner if"
      fi
      echo "after outer if"

  - name: "Error in case statement body"
    stdin: |
      set -e
      case "x" in
        x)
          echo "matched"
          false
          echo "should not print"
          ;;
      esac
      echo "after case"

  - name: "case pattern matching on non-match"
    stdin: |
      set -e
      case "x" in
        y) echo "y" ;;
        z) echo "z" ;;
      esac
      echo "after case"

  # List constructs
  - name: "Error in ; list DOES exit"
    stdin: |
      set -e
      true ; false ; echo "should not print"

  - name: "Semicolon separated commands respect set -e"
    stdin: |
      set -e
      echo "first" ; echo "second" ; false ; echo "should not print"

  # Background jobs
  - name: "Error in background job"
    stdin: |
      set -e
      false &
      wait
      echo "after wait"

  # Interaction with other options
  - name: "set -e with set -o pipefail"
    stdin: |
      set -e
      set -o pipefail
      true | false
      echo "should not print"

  - name: "set -e without pipefail allows pipeline errors"
    stdin: |
      set -e
      true | false | true
      echo "after pipeline"

  # Edge cases with test builtin
  - name: "test builtin false result in conditional"
    stdin: |
      set -e
      if test 1 -eq 2; then
        echo "then"
      else
        echo "else"
      fi
      echo "after"

  - name: "test builtin false result standalone DOES exit"
    stdin: |
      set -e
      test 1 -eq 2
      echo "should not print"

  - name: "[ builtin false result in conditional"
    stdin: |
      set -e
      if [ 1 -eq 2 ]; then
        echo "then"
      else
        echo "else"
      fi
      echo "after"

  - name: "[ builtin false result standalone DOES exit"
    stdin: |
      set -e
      [ 1 -eq 2 ]
      echo "should not print"

  - name: "trap ERR"
    known_failure: true # TODO(traps): trap ERR support
    stdin: |
      set -e
      trap 'echo "error trapped"' ERR
      false
      echo "should not print"

  - name: "trap EXIT"
    stdin: |
      set -e
      trap 'echo "exit trapped"' EXIT
      false
      echo "should not print"

  # Combination of contexts
  - name: "Error in function in conditional"
    stdin: |
      set -e
      myfunc() {
        false
      }
      if myfunc; then
        echo "then"
      else
        echo "else"
      fi
      echo "after"

  - name: "Negated function call"
    stdin: |
      set -e
      myfunc() {
        echo "in function"
        false
      }
      ! myfunc
      echo "after"

  - name: "Function in pipeline on internal error"
    stdin: |
      set -e
      myfunc() {
        false
      }
      myfunc | true
      echo "after"

  - name: "Error after function in boolean context DOES exit"
    stdin: |
      set -e
      myfunc() {
        false
      }
      myfunc || true
      false
      echo "should not print"

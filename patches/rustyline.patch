diff --git a/src/completion.rs b/src/completion.rs
index 477dfc4..8cbcdd9 100644
--- a/src/completion.rs
+++ b/src/completion.rs
@@ -90,7 +90,7 @@ pub trait Completer {
     ///
     /// ("ls /usr/loc", 11) => Ok((3, vec!["/usr/local/"]))
     fn complete(
-        &self, // FIXME should be `&mut self`
+        &mut self,
         line: &str,
         pos: usize,
         ctx: &Context<'_>,
@@ -113,11 +113,11 @@ impl Completer for () {
     }
 }
 
-impl<'c, C: ?Sized + Completer> Completer for &'c C {
+impl<'c, C: ?Sized + Completer> Completer for &'c mut C {
     type Candidate = C::Candidate;
 
     fn complete(
-        &self,
+        &mut self,
         line: &str,
         pos: usize,
         ctx: &Context<'_>,
@@ -135,7 +135,7 @@ macro_rules! box_completer {
             impl<C: ?Sized + Completer> Completer for $id<C> {
                 type Candidate = C::Candidate;
 
-                fn complete(&self, line: &str, pos: usize, ctx: &Context<'_>) -> Result<(usize, Vec<Self::Candidate>)> {
+                fn complete(&mut self, line: &str, pos: usize, ctx: &Context<'_>) -> Result<(usize, Vec<Self::Candidate>)> {
                     (**self).complete(line, pos, ctx)
                 }
                 fn update(&self, line: &mut LineBuffer, start: usize, elected: &str, cl: &mut Changeset) {
@@ -148,8 +148,8 @@ macro_rules! box_completer {
 
 use crate::undo::Changeset;
 use std::rc::Rc;
-use std::sync::Arc;
-box_completer! { Box Rc Arc }
+// use std::sync::Arc;
+box_completer! { Box /*Rc Arc*/ }
 
 /// A `Completer` for file and folder names.
 pub struct FilenameCompleter {
@@ -257,7 +257,12 @@ impl Default for FilenameCompleter {
 impl Completer for FilenameCompleter {
     type Candidate = Pair;
 
-    fn complete(&self, line: &str, pos: usize, _ctx: &Context<'_>) -> Result<(usize, Vec<Pair>)> {
+    fn complete(
+        &mut self,
+        line: &str,
+        pos: usize,
+        _ctx: &Context<'_>,
+    ) -> Result<(usize, Vec<Pair>)> {
         self.complete_path(line, pos)
     }
 }
diff --git a/src/edit.rs b/src/edit.rs
index e6881eb..45b7126 100644
--- a/src/edit.rs
+++ b/src/edit.rs
@@ -32,7 +32,7 @@ pub struct State<'out, 'prompt, H: Helper> {
     saved_line_for_history: LineBuffer, // Current edited line before history browsing
     byte_buffer: [u8; 4],
     pub changes: Changeset, // changes to line, for undo/redo
-    pub helper: Option<&'out H>,
+    pub helper: Option<&'out mut H>,
     pub ctx: Context<'out>,          // Give access to history for `hinter`
     pub hint: Option<Box<dyn Hint>>, // last hint displayed
     pub highlight_char: bool,        // `true` if a char has been highlighted
@@ -49,7 +49,7 @@ impl<'out, 'prompt, H: Helper> State<'out, 'prompt, H> {
     pub fn new(
         out: &'out mut <Terminal as Term>::Writer,
         prompt: &'prompt str,
-        helper: Option<&'out H>,
+        helper: Option<&'out mut H>,
         ctx: Context<'out>,
     ) -> State<'out, 'prompt, H> {
         let prompt_size = out.calculate_position(prompt, Position::default());
@@ -72,7 +72,7 @@ impl<'out, 'prompt, H: Helper> State<'out, 'prompt, H> {
 
     pub fn highlighter(&self) -> Option<&dyn Highlighter> {
         if self.out.colors_enabled() {
-            self.helper.map(|h| h as &dyn Highlighter)
+            self.helper.as_ref().map(|h| h as &dyn Highlighter)
         } else {
             None
         }
@@ -169,7 +169,7 @@ impl<'out, 'prompt, H: Helper> State<'out, 'prompt, H> {
             Info::Msg(msg) => msg,
         };
         let highlighter = if self.out.colors_enabled() {
-            self.helper.map(|h| h as &dyn Highlighter)
+            self.helper.as_ref().map(|h| h as &dyn Highlighter)
         } else {
             None
         };
@@ -194,7 +194,7 @@ impl<'out, 'prompt, H: Helper> State<'out, 'prompt, H> {
     }
 
     pub fn hint(&mut self) {
-        if let Some(hinter) = self.helper {
+        if let Some(hinter) = self.helper.as_ref() {
             let hint = hinter.hint(self.line.as_str(), self.line.pos(), &self.ctx);
             self.hint = match hint {
                 Some(val) if !val.display().is_empty() => Some(Box::new(val) as Box<dyn Hint>),
@@ -229,7 +229,7 @@ impl<'out, 'prompt, H: Helper> State<'out, 'prompt, H> {
     }
 
     pub fn validate(&mut self) -> Result<ValidationResult> {
-        if let Some(validator) = self.helper {
+        if let Some(validator) = &self.helper {
             self.changes.begin();
             let result = validator.validate(&mut ValidationContext::new(self))?;
             let corrected = self.changes.end();
@@ -749,7 +749,7 @@ pub fn init_state<'out, H: Helper>(
     out: &'out mut <Terminal as Term>::Writer,
     line: &str,
     pos: usize,
-    helper: Option<&'out H>,
+    helper: Option<&'out mut H>,
     history: &'out crate::history::DefaultHistory,
 ) -> State<'out, 'static, H> {
     State {
@@ -782,8 +782,8 @@ mod test {
         history.add("line0").unwrap();
         history.add("line1").unwrap();
         let line = "current edited line";
-        let helper: Option<()> = None;
-        let mut s = init_state(&mut out, line, 6, helper.as_ref(), &history);
+        let mut helper: Option<()> = None;
+        let mut s = init_state(&mut out, line, 6, helper.as_mut(), &history);
         s.ctx.history_index = history.len();
 
         for _ in 0..2 {
diff --git a/src/highlight.rs b/src/highlight.rs
index d5c0e89..df9274e 100644
--- a/src/highlight.rs
+++ b/src/highlight.rs
@@ -62,7 +62,7 @@ pub trait Highlighter {
 
 impl Highlighter for () {}
 
-impl<'r, H: ?Sized + Highlighter> Highlighter for &'r H {
+impl<'r, H: ?Sized + Highlighter> Highlighter for &'r mut H {
     fn highlight<'l>(&self, line: &'l str, pos: usize) -> Cow<'l, str> {
         (**self).highlight(line, pos)
     }
diff --git a/src/hint.rs b/src/hint.rs
index 1b4f88a..a075e44 100644
--- a/src/hint.rs
+++ b/src/hint.rs
@@ -40,7 +40,7 @@ impl Hinter for () {
     type Hint = String;
 }
 
-impl<'r, H: ?Sized + Hinter> Hinter for &'r H {
+impl<'r, H: ?Sized + Hinter> Hinter for &'r mut H {
     type Hint = H::Hint;
 
     fn hint(&self, line: &str, pos: usize, ctx: &Context<'_>) -> Option<Self::Hint> {
diff --git a/src/lib.rs b/src/lib.rs
index 9f0cee5..783fefb 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -85,9 +85,9 @@ fn complete_line<H: Helper>(
         unbounded, Skim, SkimItem, SkimItemReceiver, SkimItemSender, SkimOptionsBuilder,
     };
 
-    let completer = s.helper.unwrap();
     // get a list of completions
-    let (start, candidates) = completer.complete(&s.line, s.line.pos(), &s.ctx)?;
+    let (start, candidates) = s.helper.as_deref_mut().unwrap().complete(&s.line, s.line.pos(), &s.ctx)?;
+
     // if no completions, we are done
     if candidates.is_empty() {
         s.out.beep()?;
@@ -109,6 +109,7 @@ fn complete_line<H: Helper>(
                 } else {
                     Borrowed(candidate)
                 };*/
+                let completer = s.helper.as_deref().unwrap();
                 completer.update(&mut s.line, start, candidate, &mut s.changes);
             } else {
                 // Restore current edited line
@@ -152,6 +153,7 @@ fn complete_line<H: Helper>(
         if let Some(lcp) = longest_common_prefix(&candidates) {
             // if we can extend the item, extend it
             if lcp.len() > s.line.pos() - start || candidates.len() == 1 {
+                let completer = s.helper.as_deref().unwrap();
                 completer.update(&mut s.line, start, lcp, &mut s.changes);
                 s.refresh_line()?;
             }
@@ -551,7 +553,7 @@ where
 
 impl Helper for () {}
 
-impl<'h, H: ?Sized + Helper> Helper for &'h H {}
+impl<'h, H: ?Sized + Helper> Helper for &'h mut H {}
 
 /// Completion/suggestion context
 pub struct Context<'h> {
@@ -695,7 +697,7 @@ impl<H: Helper, I: History> Editor<H, I> {
 
         self.kill_ring.reset(); // TODO recreate a new kill ring vs reset
         let ctx = Context::new(&self.history);
-        let mut s = State::new(&mut stdout, prompt, self.helper.as_ref(), ctx);
+        let mut s = State::new(&mut stdout, prompt, self.helper.as_mut(), ctx);
 
         let mut input_state = InputState::new(&self.config, &self.custom_bindings);
 
diff --git a/src/test/mod.rs b/src/test/mod.rs
index 6eb317d..e71fd7f 100644
--- a/src/test/mod.rs
+++ b/src/test/mod.rs
@@ -30,7 +30,7 @@ impl Completer for SimpleCompleter {
     type Candidate = String;
 
     fn complete(
-        &self,
+        &mut self,
         line: &str,
         _pos: usize,
         _ctx: &Context<'_>,
@@ -63,8 +63,8 @@ impl Validator for SimpleCompleter {}
 fn complete_line() {
     let mut out = Sink::default();
     let history = crate::history::DefaultHistory::new();
-    let helper = Some(SimpleCompleter);
-    let mut s = init_state(&mut out, "rus", 3, helper.as_ref(), &history);
+    let mut helper = Some(SimpleCompleter);
+    let mut s = init_state(&mut out, "rus", 3, helper.as_mut(), &history);
     let config = Config::default();
     let bindings = Bindings::new();
     let mut input_state = InputState::new(&config, &bindings);
@@ -85,8 +85,8 @@ fn complete_line() {
 fn complete_symbol() {
     let mut out = Sink::default();
     let history = crate::history::DefaultHistory::new();
-    let helper = Some(SimpleCompleter);
-    let mut s = init_state(&mut out, "\\hbar", 5, helper.as_ref(), &history);
+    let mut helper = Some(SimpleCompleter);
+    let mut s = init_state(&mut out, "\\hbar", 5, helper.as_mut(), &history);
     let config = Config::builder()
         .completion_type(CompletionType::List)
         .build();
diff --git a/src/validate.rs b/src/validate.rs
index 8ea8aca..dd9f298 100644
--- a/src/validate.rs
+++ b/src/validate.rs
@@ -30,11 +30,11 @@ impl ValidationResult {
 
 /// Give access to user input.
 pub struct ValidationContext<'i> {
-    i: &'i mut dyn Invoke,
+    i: &'i dyn Invoke,
 }
 
 impl<'i> ValidationContext<'i> {
-    pub(crate) fn new(i: &'i mut dyn Invoke) -> Self {
+    pub(crate) fn new(i: &'i dyn Invoke) -> Self {
         ValidationContext { i }
     }
 
@@ -88,7 +88,7 @@ pub trait Validator {
 
 impl Validator for () {}
 
-impl<'v, V: ?Sized + Validator> Validator for &'v V {
+impl<'v, V: ?Sized + Validator> Validator for &'v mut V {
     fn validate(&self, ctx: &mut ValidationContext) -> Result<ValidationResult> {
         (**self).validate(ctx)
     }
